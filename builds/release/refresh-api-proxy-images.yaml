pr: none
trigger: none

resources:
  pipelines:
  - pipeline: detect-image-updates
    source: 'Detect Image Updates'
    trigger:
      branches:
        include:
        - main
  repositories:
  - repository: product
    type: github
    endpoint: Azure/azure-iotedge
    name: Azure/azure-iotedge

variables:
  Codeql.Enabled: false
  DisableDockerDetector: true

stages:
################################################################################
- stage: PrepareRelease
################################################################################
  displayName: Prepare for release
  dependsOn: []

  # The project repo must meet some prerequisites before the release pipeline can continue:
  #  1. A commit, designated as the "release commit", must be tagged with the version (e.g., api-proxy-1.1.4)
  #
  # This stage ensures the above requirements are fulfilled by running one of two mutually-exclusive
  # jobs depending on how the run was triggered. If it was triggered automatically when the
  # detect-image-updates pipeline completed, then the PipelineTrigger job runs and makes all
  # necessary file updates, commits, and tags to prepare for the release. If the pipeline was
  # triggered manually, then the ManualTrigger job runs. It assumes the prerequisites have already
  # been met, and checks to ensure it has everything it needs to continue.

  pool:
    name: $(pool.linux.name)
    demands:
    - ImageOverride -equals agent-aziotedge-ubuntu-20.04-docker

  jobs:
  - job: PipelineTrigger
    displayName: Trigger on base image updates
    condition: eq(variables['Build.Reason'], 'ResourceTrigger')

    steps:
    - checkout: self
      fetchDepth: 0

    - download: detect-image-updates
      displayName: Download image list from triggering pipeline

    - script: |
        #!/bin/bash
        set -euo pipefail

        echo 'Updates:'
        cat $(Pipeline.Workspace)/detect-image-updates/image-updates/updates.json

        . scripts/linux/release-tools.sh
        previous_version=$(TAG_PREFIX='api-proxy-' get_nearest_version)
        product='api-proxy'
        echo "Filtering on { product: $product, version: $previous_version }..."

        # We won't proceed with the release until *all* the images we build in this pipeline are
        # flagged for update, to avoid doing multiple releases in quick succession.
        continue=$(jq \
          --arg p "$product" \
          --arg v "$previous_version" '
            def filter: [
              "mcr.microsoft.com/azureiotedge-api-proxy:\($v)"
            ];
            [ .[] | select(.product == $p and .version == $v) | .images[] ] | contains(filter)
          ' $(Pipeline.Workspace)/detect-image-updates/image-updates/updates.json
        )

        echo "Continue with release? $continue"
        echo "##vso[task.setvariable variable=continue;isOutput=true]$continue"
      displayName: Filter image list for API Proxy images
      name: filter

    - task: AzureKeyVault@1
      displayName: Get secrets
      condition: and(succeeded(), eq(variables['filter.continue'], 'true'))
      inputs:
        azureSubscription: $(az.subscription)
        keyVaultName: $(kv.name)
        secretsFilter: TestGitHubAccessToken

    - script: |
        #!/bin/bash
        set -euo pipefail

        . scripts/linux/release-tools.sh

        GIT_EMAIL='$(service-account.email)' \
        BRANCH="${BUILD_SOURCEBRANCH#refs/heads/}" \
        make_project_release_commit_for_api_proxy_image_refresh
        get_api_proxy_release_info
        echo 'API Proxy release info:'
        echo "$OUTPUTS" | jq '.'

        changelog=$(echo "$OUTPUTS" | jq -rc '.changelog')
        next=$(echo "$OUTPUTS" | jq -rc '.version')
        prev=$(echo "$OUTPUTS" | jq -rc '.previous_version')
        tags=$(echo "$OUTPUTS" | jq -rc '.tags')
        tags=$(echo "$tags" | jq -c '. + ["latest"] | unique')

        echo "##vso[task.setvariable variable=changelog;isOutput=true]$changelog"
        echo "##vso[task.setvariable variable=version;isOutput=true]$next"
        echo "##vso[task.setvariable variable=previous_version;isOutput=true]$prev"
        echo "##vso[task.setvariable variable=tags;isOutput=true]$tags"
      displayName: Tag a release commit
      name: commit
      condition: and(succeeded(), eq(variables['filter.continue'], 'true'))
      env:
        GITHUB_TOKEN: "$(TestGitHubAccessToken)"

  - job: ManualTrigger
    displayName: Manually trigger pipeline to update images
    condition: eq(variables['Build.Reason'], 'Manual')

    steps:
    - checkout: self
      fetchDepth: 0

    - script: |
        #!/bin/bash
        set -euo pipefail

        # this script assumes the following steps have already been taken:
        # - a release commit is reachable from this run's source commit
        # - the release commit was tagged with the new version

        . scripts/linux/release-tools.sh
        get_api_proxy_release_info
        echo 'API Proxy release info:'
        echo "$OUTPUTS" | jq '.'

        changelog=$(echo "$OUTPUTS" | jq -rc '.changelog')
        next=$(echo "$OUTPUTS" | jq -rc '.version')
        prev=$(echo "$OUTPUTS" | jq -rc '.previous_version')
        tags=$(echo "$OUTPUTS" | jq -rc '.tags')
        tags=$(echo "$tags" | jq -c '. + ["latest"] | unique')

        echo "##vso[task.setvariable variable=changelog;isOutput=true]$changelog"
        echo "##vso[task.setvariable variable=version;isOutput=true]$next"
        echo "##vso[task.setvariable variable=previous_version;isOutput=true]$prev"
        echo "##vso[task.setvariable variable=tags;isOutput=true]$tags"
      displayName: Determine versions
      name: commit

    - script: |
        #!/bin/bash
        set -euo pipefail

        # If API proxy has already been published to mcr.microsoft.com at the given version,
        # we'll assume there's a mistake (e.g., forgot to create and/or tag a new release commit)
        # and abort the release.
        image='mcr.microsoft.com/azureiotedge-api-proxy:$(commit.version)'
        if docker buildx imagetools inspect "$image" >/dev/null 2>&1; then
          echo "Error: $image already exists but shouldn't"
          exit 1
        fi

        # Create a filter.continue task variable to match the PipelineTrigger job, but hard-code it
        # to true so the pipeline will always run subsequent stages in the manual case.
        echo "##vso[task.setvariable variable=continue;isOutput=true]true"
      displayName: Continue if the proposed version was not already released
      name: filter

################################################################################
- stage: Build
################################################################################
  displayName: Build API Proxy
  dependsOn: PrepareRelease

  condition: |
    and(
      succeeded(),
      or(
        eq(dependencies.PrepareRelease.outputs['PipelineTrigger.filter.continue'], 'true'),
        eq(dependencies.PrepareRelease.outputs['ManualTrigger.filter.continue'], 'true')
      )
    )

  pool:
    name: $(pool.linux.name)
    demands:
    - ImageOverride -equals agent-aziotedge-ubuntu-20.04-docker

  variables:
    ${{ if eq(variables['Build.Reason'], 'Manual') }}:
      version: $[ stageDependencies.PrepareRelease.ManualTrigger.outputs['commit.version'] ]
      tags: $[ stageDependencies.PrepareRelease.ManualTrigger.outputs['commit.tags'] ]
    ${{ else }}:
      version: $[ stageDependencies.PrepareRelease.PipelineTrigger.outputs['commit.version'] ]
      tags: $[ stageDependencies.PrepareRelease.PipelineTrigger.outputs['commit.tags'] ]

  jobs:
  - job: BuildExecutables
    displayName: Build Executables

    strategy:
      maxParallel: 3
      matrix:
        amd64:
          arch: "x86_64"
        arm32:
          arch: "armv7l"
        arm64:
          arch: "aarch64"

    steps:
    - checkout: self
      fetchDepth: 0

    - script: |
        git checkout api-proxy-$(version)
      displayName: Check out the release commit

    - script: |
        scripts/linux/buildAPIProxy.sh \
          -P 'api-proxy-module' \
          -c 'release' \
          --target-arch $(arch) \
          --bin-dir '$(Build.BinariesDirectory)'
      displayName: Build API Proxy - $(arch)

    - task: PublishBuildArtifacts@1
      inputs:
        pathtoPublish: '$(Build.BinariesDirectory)/publish'
        artifactName: $(arch)
        storeAsTar: true

  - job: BuildImages
    displayName: Build Docker Images
    dependsOn: BuildExecutables

    - task: DownloadBuildArtifacts@1
      displayName: Download Executables
      inputs:
        buildType: current
        downloadPath: '$(Build.ArtifactStagingDirectory)'
        downloadType: specific
        extractTars: true

    - task: CopyFiles@2
      displayName: Copy Executables - amd64
      inputs:
        sourceFolder: '$(Agent.TempDirectory)/extracted_tars/x86_64'
        contents: '**'
        targetFolder: '$(Build.BinariesDirectory)/publish'

    - task: CopyFiles@2
      displayName: Copy Executables - arm32
      inputs:
        sourceFolder: '$(Agent.TempDirectory)/extracted_tars/armv7l'
        contents: '**'
        targetFolder: '$(Build.BinariesDirectory)/publish'

    - task: CopyFiles@2
      displayName: Copy Executables - arm64
      inputs:
        sourceFolder: '$(Agent.TempDirectory)/extracted_tars/aarch64'
        contents: '**'
        targetFolder: '$(Build.BinariesDirectory)/publish'

    - task: AzureArtifacts.manifest-generator-task.manifest-generator-task.ManifestGeneratorTask@0
      displayName: Generate SBOM
      inputs:
        BuildDropPath: '$(Build.BinariesDirectory)/publish'

    - template: ../misc/templates/image-linux.yaml
      parameters:
        displayName: API Proxy
        name: azureiotedge-api-proxy
        app: api-proxy-module
        version: $(version)
        download_artifacts: false

    - task: ComponentGovernanceComponentDetection@0
      inputs:
        dockerImagesToScan: '$(registry.address)/microsoft/azureiotedge-api-proxy:$(version)-linux-amd64,$(registry.address)/microsoft/azureiotedge-api-proxy:$(version)-linux-arm32v7,$(registry.address)/microsoft/azureiotedge-api-proxy:$(version)-linux-arm64v8'

# ################################################################################
# - stage: Test
# ################################################################################
#   displayName: Test API Proxy
#   condition: succeeded('Build')
#   dependsOn:
#   - PrepareRelease
#   - Build

#   variables:
#     ${{ if eq(variables['Build.Reason'], 'Manual') }}:
#       version: $[ stageDependencies.PrepareRelease.ManualTrigger.outputs['commit.version'] ]
#     ${{ else }}:
#       version: $[ stageDependencies.PrepareRelease.PipelineTrigger.outputs['commit.version'] ]

#   jobs:
#   - job: test
#     displayName: Test Linux

#     variables:
#       os: linux
#       verbose: false

#     strategy:
#       matrix:
#         arm32v7:
#           pool: $(pool.linux.arm.name)
#           # Since this pipeline is about testing the API Proxy Docker image for release and not our
#           # host components, we'll run the arm32v7 Docker image on an arm64v8 host OS, with arm64v8
#           # host components, for speed and convenience.
#           agent: agent-aziotedge-ubuntu-20.04-arm64-docker
#           arch: arm32v7
#         arm64v8:
#           pool: $(pool.linux.arm.name)
#           agent: agent-aziotedge-ubuntu-20.04-arm64-docker
#           arch: arm64v8
#         amd64:
#           pool: $(pool.linux.name)
#           agent: agent-aziotedge-ubuntu-20.04-msmoby
#           arch: amd64

#     pool:
#       name: $(pool)
#       demands:
#       - ImageOverride -equals $(agent)

#     steps:
#     - checkout: self
#       fetchDepth: 0

#     - task: AzureKeyVault@1
#       displayName: Get secrets
#       inputs:
#         azureSubscription: $(az.subscription)
#         keyVaultName: $(kv.name)
#         secretsFilter: >-
#           ReleaseContainerRegistryPassword,
#           TestEventHubCompatibleEndpoint,
#           TestIotHubConnectionString,
#           TestIotHubResourceId,
#           TestRootCaCertificate,
#           TestRootCaKey,
#           TestRootCaPassword

#     - pwsh: |
#         $certsDir = '$(System.ArtifactsDirectory)/certs'
#         New-Item "$certsDir" -ItemType Directory -Force | Out-Null
#         $env:ROOT_CERT | Out-File -Encoding Utf8 "$certsDir/rsa_root_ca.cert.pem"
#         $env:ROOT_KEY | Out-File -Encoding Utf8 "$certsDir/rsa_root_ca.key.pem"
#         Write-Output "##vso[task.setvariable variable=certsDir]$certsDir"
#       displayName: Install CA keys
#       env:
#         ROOT_CERT: $(TestRootCaCertificate)
#         ROOT_KEY: $(TestRootCaKey)

#     - pwsh: |
#         $testDir = '$(Build.SourcesDirectory)/test/Microsoft.Azure.Devices.Edge.Test'
#         dotnet build -c Release $testDir

#         $binDir = Convert-Path "$testDir/bin/Release/net6.0"
#         Write-Output "##vso[task.setvariable variable=binDir]$binDir"
#       displayName: Build tests
#       env:
#         http_proxy: $(Agent.ProxyUrl)
#         https_proxy: $(Agent.ProxyUrl)

#     - pwsh: |
#         $caCertScriptPath = Convert-Path '$(Build.SourcesDirectory)/tools/CACertificates'
#         $rootCaCertificatePath = Convert-Path '$(certsDir)/rsa_root_ca.cert.pem';
#         $rootCaPrivateKeyPath = Convert-Path '$(certsDir)/rsa_root_ca.key.pem';
#         $runtimeVersion = (
#           (
#             (Invoke-WebRequest https://aka.ms/latest-aziot-edge).Content | ConvertFrom-Json
#           )."aziot-edge" | Select-String -Pattern '([0-9]+\.[0-9]+)\.[0-9]+'
#         ).Matches[0].Groups[1].Value
#         $edgeAgentImage = "mcr.microsoft.com/azureiotedge-agent:$runtimeVersion";
#         $edgeHubImage = "mcr.microsoft.com/azureiotedge-hub:$runtimeVersion";
#         $metricsCollectorImage = "$(registry.address)/microsoft/azureiotedge-metrics-collector:$(version)-$(os)-$(arch)"

#         echo "Edge Agent image: $edgeAgentImage"
#         echo "Edge Hub image: $edgeHubImage"
#         echo "Metrics Collector image: $metricsCollectorImage"

#         $context = @{
#           nestededge = 'false';
#           isa95Tag = 'false';
#           edgeAgentImage = "$edgeAgentImage";
#           edgeHubImage = "$edgeHubImage";
#           metricsCollectorImage = "$metricsCollectorImage";
#           iotHubResourceId = "$env:IOT_HUB_RESOURCE_ID";
#           registries = @(
#             @{
#               address = '$(registry.address)';
#               username = '$(registry.username)';
#             }
#           );
#           caCertScriptPath = "$caCertScriptPath";
#           rootCaCertificatePath = "$rootCaCertificatePath";
#           rootCaPrivateKeyPath = "$rootCaPrivateKeyPath";
#           logFile = Join-Path '$(binDir)' 'testoutput.log';
#           verbose = '$(verbose)';
#           getSupportBundle = 'true';
#           teardownTimeoutMinutes = 10;
#         }

#         if ('$(arch)' -eq 'arm32v7')
#         {
#           $context['optimizeForPerformance'] = 'false'
#           $context['setupTimeoutMinutes'] = 10
#           $context['teardownTimeoutMinutes'] = 10
#           $context['testTimeoutMinutes'] = 10
#         }

#         if ($env:AGENT_PROXYURL)
#         {
#           $context['testRunnerProxy'] = $env:AGENT_PROXYURL
#           $context['edgeProxy'] = $env:AGENT_PROXYURL
#         }

#         $context | ConvertTo-Json | Out-File -Encoding Utf8 '$(binDir)/context.json'
#         Get-Content -Path '$(binDir)/context.json'
#       displayName: Create test arguments file (context.json)
#       env:
#         IOT_HUB_RESOURCE_ID: $(TestIotHubResourceId)

#     - script: |
#         sudo --preserve-env dotnet test '$(binDir)/Microsoft.Azure.Devices.Edge.Test.dll' \
#           --no-build \
#           --logger 'trx' \
#           --filter 'MetricsCollector'
#       displayName: Run tests
#       env:
#         E2E_EVENT_HUB_ENDPOINT: $(TestEventHubCompatibleEndpoint)
#         E2E_IOT_HUB_CONNECTION_STRING: $(TestIotHubConnectionString)
#         E2E_REGISTRIES__0__PASSWORD: $(ReleaseContainerRegistryPassword)
#         E2E_ROOT_CA_PASSWORD: $(TestRootCaPassword)

#     - task: PublishTestResults@2
#       displayName: Publish test results
#       inputs:
#         testRunner: vstest
#         testResultsFiles: '**/*.trx'
#         searchFolder: $(Build.SourcesDirectory)/TestResults
#         testRunTitle: End-to-end tests ($(Build.BuildNumber) $(System.JobDisplayName))
#         buildPlatform: $(arch)
#       condition: succeededOrFailed()

#     - pwsh: |
#         $logDir = '$(Build.ArtifactStagingDirectory)/logs'
#         New-Item $logDir -ItemType Directory -Force | Out-Null
#         Out-File "$logDir/$(Build.DefinitionName)-$(Build.BuildNumber)"
#         Copy-Item "$(Build.SourcesDirectory)/TestResults" "$logDir/" -Recurse
#         # The setup fixtures run outside the scope of any test, so their logs (*-[test|device]-*.log)
#         # aren't included in the TRX. Copy them manually here.
#         Copy-Item '$(binDir)/context.json' "$logDir/"
#         Copy-Item "$(binDir)/*-test-*.log" "$logDir/"
#         Copy-Item "$(binDir)/*-device-*.log" "$logDir/"
#         Copy-Item "$(binDir)/testoutput.log" "$logDir/"
#         Copy-Item "$(binDir)/supportbundle*" "$logDir/"
#         $artifactSuffix = '$(Build.BuildNumber)-$(System.PhaseName)' -replace '_','-'
#         Write-Output "##vso[task.setvariable variable=artifactSuffix]$artifactSuffix"
#       displayName: Collect Logs
#       condition: always()

#     - task: PublishBuildArtifacts@1
#       displayName: Publish logs
#       inputs:
#         PathtoPublish: $(Build.ArtifactStagingDirectory)/logs
#         ArtifactName: logs-end-to-end-$(artifactSuffix)
#       condition: always()

################################################################################
- stage: Test
################################################################################
  displayName: Test API Proxy
  condition: succeeded('Build')
  dependsOn:
  - PrepareRelease
  - Build

  variables:
    verbose: false

  jobs:
  - job: lock_nested_agents
    displayName: Lock nested agents
    timeoutInMinutes: 180
    pool:
      name: $(pool.linux.name)
      demands:
      - ImageOverride -equals agent-aziotedge-ubuntu-22.04-msmoby
    steps:
    - task: AzureKeyVault@1
      displayName: Get secrets
      inputs:
        azureSubscription: $(az.subscription)
        KeyVaultName: edgebuildkv
        SecretsFilter: IotEdge1-PAT-msazure
    - script: |
        scripts/linux/nestedAgentLock.sh -a "$(agent.group)" -b "$(Build.BuildId)" -n 1 -u mqtt
      displayName: Lock nested agents
      env:
        PAT: "$(IotEdge1-PAT-msazure)"

  ######
  - job: setup_vm_level5
    displayName: Set up level 5
    dependsOn: lock_nested_agents
    timeoutInMinutes: 180
    variables:
      # TODO: We don't need these artifacts if we're installing production bits
      artifactName: iotedged-ubuntu20.04-amd64
      identityServiceArtifactName: packages_ubuntu-20.04_amd64
      identityServicePackageFilter: aziot-identity-service_*_amd64.deb
      level: 5
      deploymentFile: nestededge_topLayerBaseDeployment_mqtt.json
      parentName: ''
      parentDeviceId: ''
      upstreamProtocol: mqtt
    pool:
      name: $(pool.name)
      demands:
      - agent-group -equals $(agent.group)
      - Agent.OS -equals Linux
      - Agent.OSArchitecture -equals X64
      - status -equals unlocked_$(Build.BuildId)_L5_mqtt
    steps:
    - task: AzureKeyVault@1
      displayName: Get secrets
      inputs:
        azureSubscription: $(az.subscription)
        KeyVaultName: edgebuildkv
        SecretsFilter: >-
          xyz
    - task: AzureKeyVault@1
      displayName: Get secrets
      inputs:
        azureSubscription: $(az.subscription)
        KeyVaultName: edge-e2e-kv
        SecretsFilter: >-
          TestContainerRegistryPassword,
          TestIotHubConnectionString,
          TestRootCaCertificate
    - template: e2e-clean-directory.yaml
    - script: |
        echo "$ROOT_CERT" | sudo tee /usr/local/share/ca-certificates/azure-iot-test-only.root.ca.cert.pem.crt
        sudo update-ca-certificates
      displayName: Install root CA certificate
      env:
        ROOT_CERT: $(TestRootCaCertificate)
    - task: AzureCLI@2
      inputs:
        azureSubscription: $(az.subscription)
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail

          # extract IoT hub name from connection string
          hostname="$(echo "$IOTHUB_CONNSTR" | sed -n 's/HostName=\(.*\);SharedAccessKeyName.*/\1/p')"
          hubName="$(echo $hostname | sed -n 's/\(.?*\)\..*/\1/p')"

          az account set -s '$(azure.subscription)'
          deviceId="level_$(level)_$(Build.BuildId)$(upstreamProtocol)"

          echo "Creating edge device '$deviceId' on IoT hub '$hubName' in subscription '$(azure.subscription)'"
          az iot hub device-identity create -n "$hubName" -d "$deviceId" --ee -o none
          if [ "$LEVEL" != "5" ]; then
              echo "Scoping edge device to parent device '$(parentDeviceId)'"
              az iot hub device-identity parent set -d "$deviceId" -n "$hubName" --pd '$(parentDeviceId)'
          fi

          cs="$(az iot hub device-identity connection-string show \
            -d "$deviceId" -n "$hubName" --query connectionString -o tsv)"

          #set output variable to use later in the job
          echo "##vso[task.setvariable variable=connectionString]$cs"
          echo "##vso[task.setvariable variable=deviceId]$deviceId"
          echo "##vso[task.setvariable variable=iotHubName]$hubName"

          #set output variable outside job
          echo "##vso[task.setvariable variable=connectionString;isOutput=true]$cs"
          echo "##vso[task.setvariable variable=iotHubName;isOutput=true]$hubName"
          echo "##vso[task.setvariable variable=parentDeviceId;isOutput=true]$deviceId"
        env:
          IOTHUB_CONNSTR: '$(TestIotHubConnectionString)'
    - checkout: self
      clean: true
      submodules: recursive
    - script: |
        version=$(curl -s https://raw.githubusercontent.com/Azure/azure-iotedge/main/product-versions.json | jq -r '
          .channels[] | select(.name == "lts").products[] | select (.id == "aziot-edge").version
        ')
        echo "##vso[task.setvariable variable=edgeVersion;isOutput=true]$version"
      displayName: Get IoT Edge version
    - script: |
        set -euo pipefail

        echo 'Uninstall IoT Edge'
        sudo systemctl stop aziot-* && sudo apt-get -y purge aziot-*

        echo 'Delete config files'
        sudo rm -r /var/lib/aziot /var/lib/iotedge /etc/aziot /etc/systemd/system/aziot-*.service.d

        echo 'Restart Docker'
        sudo systemctl restart docker # needed due to https://github.com/moby/moby/issues/23302

        echo 'Install IoT Edge'
        sudo apt-get -y install aziot-edge

        export image_architecture_label=amd64

        sudo scripts/linux/nested-edge-deploy-agent.sh \
          -testDir "$(Agent.HomeDirectory)/.." \h
          -releaseLabel "ct$(agent.group)" \
          -artifactImageBuildNumber '$(edgeVersion)' \
          -containerRegistry "$(cr.address)" \
          -containerRegistryUsername "$(cr.username)" \
          -containerRegistryPassword "$REGISTRY_PASSWORD" \
          -iotHubConnectionString "$IOTHUB_CONNSTR" \
          -deploymentFileName "$(deploymentFile)" \
          -storageAccountConnectionString "none" \
          -edgeRuntimeBuildNumber "$(Build.BuildNumber)" \
          -subscription "$(azure.subscription)" \
          -level "$(level)" \
          -parentName "$(parentName)" \
          -connectionString "$DEVICE_CONNSTR" \
          -iotHubName "$(iotHubName)" \
          -deviceId "$(deviceId)" \
          -waitForTestComplete \
          -cleanAll
      displayName: Install and configure IoT Edge
      env:
        DEVICE_CONNSTR: '$(connectionString)'
        IOTHUB_CONNSTR: '$(TestIotHubConnectionString)'
        REGISTRY_PASSWORD: '$(TestContainerRegistryPassword)'

  - job: setup_vm_level4
    displayName: Set up level 4
    dependsOn: setup_vm_level5
    timeoutInMinutes: 180
    variables:
      identityServiceArtifactName: packages_ubuntu-20.04_amd64
      identityServicePackageFilter: aziot-identity-service_*_amd64.deb
      artifactName: iotedged-ubuntu20.04-amd64
      parentName: $[ dependencies.setup_vm_level5.outputs['deployIoTEdge.deviceName'] ]
      parentDeviceId: $[ dependencies.setup_vm_level5.outputs['createIdentity.parentDeviceId'] ]
      deploymentFile: nestededge_middleLayerBaseDeployment_mqtt.json
      level: 4
      upstreamProtocol: mqtt
    pool:
     name: $(pool.name)
     demands:
       - agent-group -equals $(agent.group)
       - Agent.OS -equals Linux
       - Agent.OSArchitecture -equals X64
       - status -equals unlocked_$(Build.BuildId)_L4_mqtt
    steps:
      - template: nested-get-secrets.yaml
      - template: e2e-clean-directory.yaml
      - template: nested-get-root-ca.yaml
      - template: nested-create-identity.yaml
      - template: nested-agent-deploy.yaml
  ######

  - template: templates/nested-parent-vm-setup.yaml
    parameters:
      depends: lock_nested_agents
      upstream.protocol: mqtt
      test.l4DeploymentFileName: 'nestededge_middleLayerBaseDeployment_mqtt.json'

  - job:  SetupVM_and_RunTest_level3
    dependsOn:
    - setup_vm_level5
    - setup_vm_level4
    displayName: Set up and run tests
    timeoutInMinutes: 180
    condition: succeeded()
    variables:
      parentName: $[ dependencies.setup_vm_level4.outputs['deployIoTEdge.deviceName'] ]
      parentDeviceId: $[ dependencies.setup_vm_level4.outputs['createIdentity.parentDeviceId'] ]
      lvl5DeviceId: $[ dependencies.setup_vm_level5.outputs['createIdentity.parentDeviceId'] ]
      iotHubName: $[ dependencies.setup_vm_level5.outputs['createIdentity.iotHubName'] ]
      os: linux
      arch: amd64
      artifactName: iotedged-ubuntu20.04-amd64
      identityServiceArtifactName: packages_ubuntu-20.04_amd64
      identityServicePackageFilter: aziot-identity-service_*_amd64.deb
      nestededge: true
    pool:
      name: $(pool.name)
      demands:
        - agent-group -equals $(agent.group)
        - Agent.OS -equals Linux
        - Agent.OSArchitecture -equals X64
        - status -equals unlocked_$(Build.BuildId)_L3_mqtt
    steps:
    - task: AzureKeyVault@1
      displayName: 'Get secrets from edgebuildkv'
      inputs:
        azureSubscription: $(az.subscription)
        KeyVaultName: edgebuildkv
        SecretsFilter: >-
          GitHubAccessToken,
          IotEdge1-PAT-msazure

    - task: AzureKeyVault@1
      displayName: 'Get secrets from $(azure.keyVault)'
      inputs:
        azureSubscription: $(az.subscription)
        KeyVaultName: $(azure.keyVault)
        SecretsFilter: >-
          IotHub-ConnStr,
          IotHub-EventHubConnStr

    - template: templates/e2e-clean-directory.yaml
    - template: templates/nested-get-root-ca.yaml
    - template: templates/nested-get-device-name.yaml
    - template: templates/e2e-setup.yaml
    - template: templates/e2e-clear-docker-cached-images.yaml
    - template: templates/e2e-run.yaml
      parameters:
        EventHubCompatibleEndpoint: '$(IotHub-EventHubConnStr)'
        IotHubConnectionString: '$(IotHub-ConnStr)'
        test_type: nestededge_mqtt
    - template: templates/nested-deploy-config.yaml
      parameters:
        deviceId: $(lvl5DeviceId)
        deploymentFile: nestededge_topLayerBaseDeployment_amqp.json
        changeDeployConfigOnly: true
        level: 5
        name: 5
    - template: templates/nested-deploy-config.yaml
      parameters:
        deviceId: $(parentDeviceId)
        deploymentFile: nestededge_middleLayer_e2e_amqp.json
        changeDeployConfigOnly: true
        level: 4
        name: 4
    - template: templates/e2e-run.yaml
      parameters:
        EventHubCompatibleEndpoint: '$(IotHub-EventHubConnStr)'
        IotHubConnectionString: '$(IotHub-ConnStr)'
        test_type: nestededge_amqp

  - job:  Unlock_agents
    displayName: Unlock agents
    dependsOn: SetupVM_and_RunTest_level3
    condition: always()
    timeoutInMinutes: 2
    pool:
      name: $(pool.name)
      demands:
        - agent-group -equals $(agent.group)
        - Agent.OS -equals Linux
        - Agent.OSArchitecture -equals X64
    steps:
    - task: AzureKeyVault@1
      displayName: 'Get secrets from edgebuildkv'
      inputs:
        azureSubscription: $(az.subscription)
        KeyVaultName: edgebuildkv
        SecretsFilter: >-
          GitHubAccessToken,
          IotEdge1-PAT-msazure
    - template: templates/unlock-test-agents.yaml

  - job:  Clean_up_identities
    displayName: Clean up identities
    dependsOn: SetupVM_and_RunTest_level3
    condition: always()
    timeoutInMinutes: 2
    variables:
      deviceLvl5DeviceId: $[ dependencies.setup_vm_level5.outputs['createIdentity.parentDeviceId'] ]
      deviceLvl4DeviceId: $[ dependencies.setup_vm_level4.outputs['createIdentity.parentDeviceId'] ]
      deviceLvl5IoTHubName: $[ dependencies.setup_vm_level5.outputs['createIdentity.iotHubName'] ]
      deviceLvl4IoTHubName: $[ dependencies.setup_vm_level4.outputs['createIdentity.iotHubName'] ]
    pool:
      name: $(pool.name)
      demands:
        - agent-group -equals $(agent.group)
        - Agent.OS -equals Linux
        - Agent.OSArchitecture -equals X64
    steps:
      - template: templates/nested-get-secrets.yaml
      - template: templates/nested-clean-identity.yaml
        parameters:
          iotHubName: $(deviceLvl5IoTHubName)
          deviceId: $(deviceLvl5DeviceId)
          lvl: 5
      - template: templates/nested-clean-identity.yaml
        parameters:
          iotHubName: $(deviceLvl4IoTHubName)
          deviceId: $(deviceLvl4DeviceId)
          lvl: 4







################################################################################
- stage: Publish
################################################################################
  displayName: Publish API Proxy
  condition: succeeded('Test')
  dependsOn:
  - PrepareRelease
  - Test

  pool:
    name: $(pool.linux.name)
    demands:
    - ImageOverride -equals agent-aziotedge-ubuntu-20.04-docker

  variables:
    ${{ if eq(variables['Build.Reason'], 'Manual') }}:
      changelog: $[ stageDependencies.PrepareRelease.ManualTrigger.outputs['commit.changelog'] ]
      tags: $[ stageDependencies.PrepareRelease.ManualTrigger.outputs['commit.tags'] ]
      version: $[ stageDependencies.PrepareRelease.ManualTrigger.outputs['commit.version'] ]
      version.previous: $[ stageDependencies.PrepareRelease.ManualTrigger.outputs['commit.previous_version'] ]
    ${{ else }}:
      changelog: $[ stageDependencies.PrepareRelease.PipelineTrigger.outputs['commit.changelog'] ]
      tags: $[ stageDependencies.PrepareRelease.PipelineTrigger.outputs['commit.tags'] ]
      version: $[ stageDependencies.PrepareRelease.PipelineTrigger.outputs['commit.version'] ]
      version.previous: $[ stageDependencies.PrepareRelease.PipelineTrigger.outputs['commit.previous_version'] ]

  jobs:
  - job: publish
    displayName: Publish Linux

    steps:
    - checkout: self
      fetchDepth: 0
    - checkout: product
      fetchDepth: 0

    - task: Docker@2
      displayName: Docker login
      inputs:
        command: login
        containerRegistry: $(service-connection.registry)

    - script: |
        scripts/linux/copy-multi-platform-image.sh \
          --registry '$(registry.address)' \
          --repo-src 'microsoft/azureiotedge-api-proxy' \
          --repo-dst 'public/azureiotedge-api-proxy' \
          --tag '$(version)' \
          --tags-add '$(tags)'
      displayName: Publish API Proxy images
      workingDirectory: iotedge

    - task: AzureKeyVault@1
      displayName: Get secrets
      inputs:
        azureSubscription: $(az.subscription)
        keyVaultName: $(kv.name)
        secretsFilter: TestGitHubAccessToken

    - script: |
        #!/bin/bash
        set -euo pipefail

        COMMITISH="${BUILD_SOURCEBRANCH#refs/heads/}"
        COMMITISH="${BUILD_SOURCEBRANCH#refs/tags/}"

        # deserialize the changelog
        printf -v CHANGELOG '$(changelog)'
        # Remove 1st line (header) because GitHub Release page has its own header
        CHANGELOG="$(echo "$CHANGELOG" | tail -n +2 -)"

        . scripts/linux/release-tools.sh
        create_github_release_page_for_api_proxy_in_project_repo
      displayName: Create GitHub release page in project repo
      env:
        VERSION: $(version)
        GITHUB_TOKEN: $(TestGitHubAccessToken)
        REPO_NAME: $(repo.project.name)
      workingDirectory: iotedge

    - script: |
        #!/bin/bash
        set -euo pipefail

        # in case commits were made after this pipeline started but before we arrived here, sync to
        # the tip of the branch
        git checkout "$PRODUCT_REPO_BRANCH"

        # update product-versions.json
        echo "$(jq '
          def product: .channels[] | .products[] | select(
            .id=="api-proxy" and .version=="$(version.previous)"
          );
          def api_proxy: product | .components[] | select(
            .name=="azureiotedge-api-proxy"
          );
          (api_proxy).version |= "$(version)"
            | (product).version |= "$(version)"
        ' product-versions.json )" > product-versions.json
        git add product-versions.json

        # configure git
        git config user.email '$(service-account.email)'
        git config user.name 'IoT Edge Bot'
        origin_url="$(git config --get remote.origin.url)"
        origin_url="${origin_url/#https:\/\//https:\/\/$GITHUB_TOKEN@}" # add token to URL

        # commit changes and push
        git commit -m 'Bump API Proxy in product-versions.json'
        git push "$origin_url" "HEAD:$PRODUCT_REPO_BRANCH"
      displayName: Update product-versions.json in product repo
      env:
        GITHUB_TOKEN: $(TestGitHubAccessToken)
        PRODUCT_REPO_BRANCH: main
      workingDirectory: azure-iotedge
